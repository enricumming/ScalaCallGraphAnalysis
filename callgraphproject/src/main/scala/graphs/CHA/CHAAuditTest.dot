digraph CallGraph {
  node [shape=box];
  "showBasicBlocks(basicBlocks)" [style=filled, fillcolor=white];
  "args(1)" [style=filled, fillcolor=white];
  "analyzeFile(_, writer)" [style=filled, fillcolor=white];
  "println(tree.structure)" [style=filled, fillcolor=white];
  "println(\"This will never print\")" [style=filled, fillcolor=white];
  "MyHandlerCache.apply()" [style=filled, fillcolor=red];
  "Files.isDirectory()" [style=filled, fillcolor=white];
  "println(s\"ASTs written to file: $outputFile\")" [style=filled, fillcolor=white];
  "functionA()" [style=filled, fillcolor=white];
  "println(s\"Error: File ${args(0)} is not a valid file.\")" [style=filled, fillcolor=white];
  "println(s\"Error parsing ${args(0)}: $msg\")" [style=filled, fillcolor=white];
  "println(\"An unexpected exception occurred: \" + e.getMessage)" [style=filled, fillcolor=white];
  "writeCFGToDotFile(nodes, edges, outputFile)" [style=filled, fillcolor=white];
  "GetBasicBlocks.nextBlockId()" [style=filled, fillcolor=red];
  "CFG.writeCFGToDotFile()" [style=filled, fillcolor=red];
  "args(0)" [style=filled, fillcolor=white];
  "CFG.nextBlockId()" [style=filled, fillcolor=red];
  "functionB()" [style=filled, fillcolor=white];
  "println(\"Usage: GetBasicBlocks <scala-file>\")" [style=filled, fillcolor=white];
  "generateCFG(tree)" [style=filled, fillcolor=white];
  "graph.toString()" [style=filled, fillcolor=white];
  "writer.close()" [style=filled, fillcolor=white];
  "println(s\"Iteration: $i\")" [style=filled, fillcolor=white];
  "println(\"Usage: AbstractSyntaxTreeGenerator <project-root-path> <output-file>\")" [style=filled, fillcolor=white];
  "PrintWriter.<init>()" [style=filled, fillcolor=white];
  "println(\"Done with division\")" [style=filled, fillcolor=white];
  "Source.fromFile()" [style=filled, fillcolor=white];
  "println(\"Null pointer exception occurred\")" [style=filled, fillcolor=white];
  "println(\"Uso: CallGraphGenerator <archivo_input.scala> <archivo_output.dot>\")" [style=filled, fillcolor=white];
  "StringBuilder.<init>()" [style=filled, fillcolor=white];
  "println(x)" [style=filled, fillcolor=white];
  "println(s\"Error: Path ${args(0)} is not a valid directory.\")" [style=filled, fillcolor=white];
  "Files.walk()" [style=filled, fillcolor=white];
  "println(\"Cannot divide by zero\")" [style=filled, fillcolor=white];
  "sys.exit()" [style=filled, fillcolor=white];
  "Files.isRegularFile()" [style=filled, fillcolor=white];
  "println(s\"CFG written to file: $outputFile\")" [style=filled, fillcolor=white];
  "Paths.get()" [style=filled, fillcolor=white];
  "println(\"Usage: ControlFlowGraphGenerator <scala-file> <output-dot-file>\")" [style=filled, fillcolor=white];
  "CFG.isUnreachable()" [style=filled, fillcolor=red];
  "extractBasicBlocks(tree)" [style=filled, fillcolor=white];
  "graph.append()" [style=filled, fillcolor=white];
  "String.<init>()" [style=filled, fillcolor=white];
  "println(s\"Call graph generado en $outputFilePath\")" [style=filled, fillcolor=white];
  "source.collect()" [style=filled, fillcolor=white];
  "User.identifier()" [style=filled, fillcolor=red];
  "edges.foreach()" [style=filled, fillcolor=white];
  "System.exit()" [style=filled, fillcolor=white];
  "ASTGenerator.extractDetails()" [style=filled, fillcolor=red];
  "writer.write()" [style=filled, fillcolor=white];
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.List(matchBlock.expr)";
  "CFG.main()" -> "println(s\"CFG written to file: $outputFile\")";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"Then: ${ifNode.thenp.syntax}\")";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.List(tryBlockBody)";
  "AbstractSyntaxTreeGenerator.analyzeFile()" -> "AbstractSyntaxTreeGenerator.printAST(convertTreeToNode(tree), 0, writer)";
  "AbstractSyntaxTreeGenerator.printAST()" -> "AbstractSyntaxTreeGenerator.printAST(_, indent + 1, writer)";
  "CallGraphGenerator.main()" -> "PrintWriter.<init>()";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.List(doWhileBlock.expr)";
  "ASTGenerator.main()" -> "Files.walk()";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"Catch Body: ${caseBlock.body.syntax}\")";
  "CFG.generateCFG()" -> "CFG.CFGEdge(currentNode, thenNode)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.Some(BasicBlock(nextBlockId(), flattenBlock(ifBlock.elsep)))";
  "CallGraphGenerator.main()" -> "edges.foreach()";
  "CFG.extractCFGNodes()" -> "CFG.List()";
  "CFG.generateCFG()" -> "CFG.CFGEdge(currentNode, caseNode)";
  "GetBasicBlocks.showBasicBlocks()" -> "GetBasicBlocks.println(s\"  ${stmt.structure}\")";
  "Example.main()" -> "println(x)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), List(whileBlock.expr))";
  "CFG.generateCFG()" -> "CFG.CFGEdge(currentNode, bodyNode)";
  "CFG.generateCFG()" -> "CFG.CFGEdge(bodyNode, incrementNode)";
  "CallGraphGenerator.main()" -> "writer.write()";
  "CFG.main()" -> "println(s\"Error parsing ${args(0)}: $msg\")";
  "MyDeadboltHandler.getSubject()" -> "MyDeadboltHandler.User(\"ok\")";
  "AbstractSyntaxTreeGenerator.main()" -> "Files.walk()";
  "ASTGenerator.main()" -> "analyzeFile(_, writer)";
  "CFG.generateCFG()" -> "CFG.nodes(i + 4)";
  "ASTGenerator.main()" -> "Files.isDirectory()";
  "CFG.generateCFG()" -> "CFG.nodes(i + 2)";
  "NewExample.functionE()" -> "NewExample.println(\"Function E\")";
  "NewExample.functionB()" -> "NewExample.functionC()";
  "CFG.generateCFG()" -> "CFG.CFGEdge(catchBodyNode, finallyNode)";
  "MyDeadboltHandler.getSubject()" -> "MyDeadboltHandler.Some(User(\"ok\"))";
  "ControlFlowExample.main()" -> "println(\"Cannot divide by zero\")";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), List(Lit.String(s\"Match Case: ${caseBlock.pat.syntax}\")))";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), stmt.syntax)";
  "Example2.main()" -> "println(x)";
  "CFG.generateCFG()" -> "CFG.CFGEdge(currentNode, nextNode)";
  "ASTGenerator.main()" -> "writer.close()";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.List(stmt)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), List(stmt))";
  "CFG.generateCFG()" -> "CFG.CFGEdge(thenNode, nodes(i + 1))";
  "NewExample.functionA()" -> "NewExample.functionC()";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.flattenBlock(forBlock.body)";
  "CallGraphGenerator.main()" -> "System.exit()";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.flattenBlock(doWhileBlock.body)";
  "CFG.generateCFG()" -> "CFG.CFGEdge(currentNode, finallyNode)";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"Finally Block: ${finallyBlock.syntax}\")";
  "CFG.extractCFGNodes()" -> "CFG.nextBlockId()";
  "AbstractSyntaxTreeGenerator.main()" -> "println(\"Usage: AbstractSyntaxTreeGenerator <project-root-path> <output-file>\")";
  "AbstractSyntaxTreeGenerator.main()" -> "sys.exit()";
  "CFG.generateCFG()" -> "CFG.CFGEdge(currentNode, catchNode)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), flattenBlock(doWhileBlock.body))";
  "CustomDeadboltHook.bindings()" -> "CustomDeadboltHook.Seq(bind[HandlerCache].to[MyHandlerCache])";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), flattenBlock(caseBlock.body))";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), functionBlock.params)";
  "GetBasicBlocks.showBasicBlocks()" -> "GetBasicBlocks.println(s\"  ${stmt.syntax}\")";
  "ControlFlowExample.main()" -> "println(s\"Iteration: $i\")";
  "NewExample.functionB()" -> "NewExample.println(\"Function B\")";
  "GetBasicBlocks.main()" -> "println(s\"Error parsing ${args(0)}: $msg\")";
  "CFG.main()" -> "writeCFGToDotFile(nodes, edges, outputFile)";
  "NewExample.functionA()" -> "NewExample.println(\"Function A\")";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), forYieldBlock.enums)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.Some(BasicBlock(nextBlockId(), flattenBlock(finallyBody)))";
  "CFG.generateCFG()" -> "CFG.nodes(j)";
  "writer.write()" -> "graph.toString()";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.flattenBlock(functionBlock.body)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.flattenBlock(ifBlock.thenp)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), flattenBlock(functionBlock.body))";
  "CFG.generateCFG()" -> "CFG.CFGEdge(currentNode, elseNode)";
  "GetBasicBlocks.main()" -> "sys.exit()";
  "CFG.generateCFG()" -> "CFG.nodes(i + 1)";
  "GetBasicBlocks.main()" -> "Paths.get()";
  "GetBasicBlocks.showBasicBlocks()" -> "GetBasicBlocks.println(\"-\" * 40)";
  "CFG.main()" -> "sys.exit()";
  "ASTGenerator.main()" -> "sys.exit()";
  "CFG.generateCFG()" -> "CFG.CFGEdge(currentNode, nodes(i + 2))";
  "CallGraphGenerator.main()" -> "writer.close()";
  "ASTGenerator.main()" -> "println(\"Usage: AbstractSyntaxTreeGenerator <project-root-path> <output-file>\")";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), flattenBlock(tryBlock.expr))";
  "GetBasicBlocks.main()" -> "String.<init>()";
  "CFG.generateCFG()" -> "CFG.nodes(i)";
  "CallGraphGenerator.main()" -> "StringBuilder.<init>()";
  "ASTGenerator.analyzeFile()" -> "ASTGenerator.convertTreeToNode(tree)";
  "CFG.generateCFG()" -> "CFG.extractCFGNodes(tree)";
  "CFG.main()" -> "println(tree.structure)";
  "Example2.main()" -> "println(\"This will never print\")";
  "ASTGenerator.convertTreeToNode()" -> "ASTGenerator.extractDetails(tree)";
  "ASTGenerator.analyzeFile()" -> "ASTGenerator.prettyPrintAST(astNode, 0, writer)";
  "CFG.generateCFG()" -> "CFG.CFGEdge(incrementNode, conditionNode)";
  "CFG.generateCFG()" -> "CFG.CFGEdge(bodyNode, currentNode)";
  "GetBasicBlocks.main()" -> "Files.isRegularFile()";
  "GetBasicBlocks.main()" -> "extractBasicBlocks(tree)";
  "CFG.generateCFG()" -> "CFG.CFGEdge(currentNode, conditionNode)";
  "GetBasicBlocks.flattenBlock()" -> "GetBasicBlocks.List(tree)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.List(enumeratorsBlock, bodyBlock)";
  "CFG.generateCFG()" -> "CFG.CFGEdge(caseNode, bodyNode)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.flattenBlock(whileBlock.body)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), flattenBlock(finallyBody))";
  "GetBasicBlocks.main()" -> "showBasicBlocks(basicBlocks)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), flattenBlock(forBlock.body))";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"Else: ${ifNode.elsep.syntax}\")";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.println(s\"Block structure: ${block.structure}\")";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"Case: ${caseBlock.pat.syntax}\")";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.List(ifBlock.cond)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), flattenBlock(ifBlock.thenp))";
  "CFG.generateCFG()" -> "CFG.nodes(i + 3)";
  "MyDeadboltHandler.onAuthFailure()" -> "MyDeadboltHandler.Future({
      Results.Ok(Json.toJson(\"login\"))
    })";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.List(conditionBlock, thenBlock)";
  "CallGraphGenerator.main()" -> "graph.append()";
  "User.permissions()" -> "User.List()";
  "CFG.generateCFG()" -> "CFG.CFGEdge(conditionNode, currentNode)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), flattenBlock(forYieldBlock.body))";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"While Body: ${whileNode.body.syntax}\")";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), List(matchBlock.expr))";
  "ASTGenerator.convertTreeToNode()" -> "ASTGenerator.ASTNode(name, details, children)";
  "Paths.get()" -> "args(0)";
  "GetBasicBlocks.showBasicBlocks()" -> "GetBasicBlocks.println(s\"Basic Block ${block.id}:\")";
  "GetBasicBlocks.main()" -> "println(s\"Error: File ${args(0)} is not a valid file.\")";
  "GetBasicBlocks.main()" -> "println(\"Usage: GetBasicBlocks <scala-file>\")";
  "NewExample.functionC()" -> "NewExample.println(\"Function C\")";
  "Paths.get()" -> "args(1)";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"Condition: ${ifNode.cond.syntax}\")";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"Case Body: ${caseBlock.body.syntax}\")";
  "CFG.generateCFG()" -> "CFG.bodyCaseNodes(caseIndex)";
  "CallGraphGenerator.main()" -> "println(s\"Call graph generado en $outputFilePath\")";
  "CFG.main()" -> "println(\"Usage: ControlFlowGraphGenerator <scala-file> <output-dot-file>\")";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.flattenBlock(finallyBody)";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"For Initial variable: $variable = ${start.syntax}\")";
  "ASTGenerator.prettyPrintAST()" -> "ASTGenerator.prettyPrintAST(_, indent + 1, writer)";
  "GetBasicBlocks.showBasicBlocks()" -> "GetBasicBlocks.println(\"Basic Blocks Created:\")";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.flattenBlock(ifBlock.elsep)";
  "CFG.generateCFG()" -> "CFG.catchBodyNodes(catchIndex)";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"Catch: ${caseBlock.pat.syntax}\")";
  "NewExample.main()" -> "functionB()";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"While Condition: ${whileNode.expr.syntax}\")";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.flattenBlock(tryBlock.expr)";
  "User.roles()" -> "User.List()";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"For Body: ${forNode.body.syntax}\")";
  "CallGraphGenerator.main()" -> "source.collect()";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"Try Block: ${tryCatchNode.expr.syntax}\")";
  "MyDeadboltHandler.getDynamicResourceHandler()" -> "MyDeadboltHandler.Future({None})";
  "ControlFlowExample.main()" -> "println(\"Done with division\")";
  "CFG.generateCFG()" -> "CFG.nodes(nextNodeIndex)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.List(Lit.String(s\"Match Case: ${caseBlock.pat.syntax}\"))";
  "ASTGenerator.main()" -> "Paths.get()";
  "AbstractSyntaxTreeGenerator.main()" -> "Files.isRegularFile()";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"Do While Body: ${doWhileNode.body.syntax}\")";
  "AbstractSyntaxTreeGenerator.main()" -> "writer.close()";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), List(ifBlock.cond))";
  "MyDeadboltHandler.beforeAuthCheck()" -> "MyDeadboltHandler.Future({None})";
  "CFG.main()" -> "Paths.get()";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.List(paramsBlock, bodyBlock)";
  "CallGraphGenerator.main()" -> "args(0)";
  "CFG.main()" -> "println(s\"Error: File ${args(0)} is not a valid file.\")";
  "AbstractSyntaxTreeGenerator.main()" -> "Paths.get()";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.flattenBlock(caseBlock.body)";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"Do Condition: ${doWhileNode.expr.syntax}\")";
  "AbstractSyntaxTreeGenerator.main()" -> "println(s\"ASTs written to file: $outputFile\")";
  "CallGraphGenerator.main()" -> "Source.fromFile()";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.List(matchExprBlock)";
  "ASTGenerator.main()" -> "println(s\"Error: Path ${args(0)} is not a valid directory.\")";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.List(conditionBlock, bodyBlock)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), List(doWhileBlock.expr))";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), flattenBlock(whileBlock.body))";
  "ControlFlowExample.main()" -> "println(\"An unexpected exception occurred: \" + e.getMessage)";
  "CFG.main()" -> "String.<init>()";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.List(bodyBlock, conditionBlock)";
  "NewExample.functionB()" -> "NewExample.functionD()";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"For Increment: $variable++\")";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.println(s\"Block syntax: ${block.syntax}\")";
  "CFG.generateCFG()" -> "CFG.CFGEdge(catchNode, catchBodyNode)";
  "AbstractSyntaxTreeGenerator.main()" -> "analyzeFile(_, writer)";
  "CFG.generateCFG()" -> "CFG.CFGEdge(conditionNode, nextNode)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.List(caseConditionBlock, caseBodyBlock)";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"For Condition: $variable <= ${end.syntax}\")";
  "CFG.generateCFG()" -> "CFG.println(s\"Warning: Not enough nodes to process the For loop at index $i.\")";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), flattenBlock(ifBlock.elsep))";
  "MyDeadboltHandler.getSubject()" -> "MyDeadboltHandler.Future({
      request.subject.orElse {
        // replace request.session.get(\"userId\") with how you identify the user
        request.session.get(\"userId\") match {
          case Some(userId) => Some(User(\"ok\"))
            // get from database, identity platform, cache, etc, if some
            // identifier is present in the request
          case _ => None
        }
      }})";
  "ASTGenerator.main()" -> "Files.isRegularFile()";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.flattenBlock(forYieldBlock.body)";
  "CFG.main()" -> "generateCFG(tree)";
  "CallGraphGenerator.main()" -> "println(\"Uso: CallGraphGenerator <archivo_input.scala> <archivo_output.dot>\")";
  "CFG.generateCFG()" -> "CFG.CFGEdge(bodyNode, nodes(nextNodeIndex))";
  "CFG.generateCFG()" -> "CFG.CFGEdge(conditionNode, exitNode)";
  "AbstractSyntaxTreeGenerator.main()" -> "Files.isDirectory()";
  "edges.foreach()" -> "graph.append()";
  "CFG.main()" -> "Files.isRegularFile()";
  "AbstractSyntaxTreeGenerator.main()" -> "PrintWriter.<init>()";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.List(whileBlock.expr)";
  "ControlFlowExample.main()" -> "println(\"Null pointer exception occurred\")";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.nextBlockId()";
  "CFG.extractCFGNodes()" -> "CFG.CFGNode(nextBlockId(), s\"Match expression: ${matchNode.expr.syntax}\")";
  "AbstractSyntaxTreeGenerator.main()" -> "println(s\"Error: Path ${args(0)} is not a valid directory.\")";
  "CFG.generateCFG()" -> "CFG.CFGEdge(conditionNode, bodyNode)";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.List(BasicBlock(nextBlockId(), List(stmt)))";
  "NewExample.functionD()" -> "NewExample.functionE()";
  "NewExample.functionD()" -> "NewExample.println(\"Function D\")";
  "CallGraphGenerator.main()" -> "args(1)";
  "AbstractSyntaxTreeGenerator.convertTreeToNode()" -> "AbstractSyntaxTreeGenerator.ASTNode(tree.productPrefix, tree.children.map(convertTreeToNode))";
  "AbstractSyntaxTreeGenerator.analyzeFile()" -> "AbstractSyntaxTreeGenerator.convertTreeToNode(tree)";
  "GetBasicBlocks.addBlock()" -> "GetBasicBlocks.BasicBlock(blockIdCounter, statements)";
  "NewExample.main()" -> "functionA()";
  "GetBasicBlocks.extractBasicBlocks()" -> "GetBasicBlocks.BasicBlock(nextBlockId(), forBlock.enums)";
  "ASTGenerator.main()" -> "println(s\"ASTs written to file: $outputFile\")";
  "ASTGenerator.main()" -> "PrintWriter.<init>()";
}
